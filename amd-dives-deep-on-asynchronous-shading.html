<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="IE=edge"><title>AMD Dives Deep On Asynchronous Shading | GleamDash</title><meta name=generator content="Hugo 0.98.0"><meta name=description content="Earlier this month at GDC, AMD introduced their VR technology toolkit, LiquidVR. LiquidVR offers game developers a collection of useful tools and technologies for adding high performance VR to games, including features to make better utilization of multiple GPUs, features to reduce display chain latency, and finally features to reduce rendering latency. Key among the latter features set is support for asynchronous shaders, which is the ability to execute certain shader operations concurrently with other rendering operations, rather than in a traditional serial fashion."><link rel=stylesheet href=https://assets.cdnweb.info/hugo/cayman/css/normalize.css><link href="https://fonts.googleapis.com/css?family=Open+Sans:400,700" rel=stylesheet type=text/css><link rel=stylesheet href=https://assets.cdnweb.info/hugo/cayman/css/cayman.css><link rel=apple-touch-icon sizes=180x180 href=./apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=./favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=./favicon-16x16.png><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.css integrity=sha384-yFRtMMDnQtDRO8rLpMIKrtPCD5jdktao2TV19YiZYWMDkUR5GQZR/NOVTdquEx1j crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.js integrity=sha384-9Nhn55MVVN0/4OFx7EE5kpFBPsEMZxKTCnA+4fqDmg12eCTqGi6+BB2LjY8brQxJ crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/contrib/auto-render.min.js integrity=sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI crossorigin=anonymous onload=renderMathInElement(document.body)></script></head><body><section class=page-header><h1 class=project-name>GleamDash</h1><h2 class=project-tagline></h2><nav><a href=./index.html class=btn>Blog</a>
<a href=./sitemap.xml class=btn>Sitemap</a>
<a href=./index.xml class=btn>RSS</a></nav></section><section class=main-content><h1>AMD Dives Deep On Asynchronous Shading</h1><div><strong>Publish date: </strong>2024-07-07</div><p>Earlier this month at GDC, AMD introduced their VR technology toolkit, <a href=#>LiquidVR</a>. LiquidVR offers game developers a collection of useful tools and technologies for adding high performance VR to games, including features to make better utilization of multiple GPUs, features to reduce display chain latency, and finally features to reduce rendering latency. Key among the latter features set is support for asynchronous shaders, which is the ability to execute certain shader operations concurrently with other rendering operations, rather than in a traditional serial fashion.</p><p>It’s this last item that ended up kicking up a surprisingly deep conversation between myself, AMD’s “Chief Gaming Scientist” Richard Huddy, and other members of AMD’s GDC staff. AMD was keen to show off the performance potential of async shaders, but in the process we reached the realization that to this point AMD hasn’t talked very much about their async execution abilities within the GCN architecture, particularly within a graphics context as opposed to a compute context. While the idea of async shaders is pretty simple – executing shaders concurrently (and yet not in sync with) other operations – it’s a bit less obvious just what the real-world benefits are why this matters. After all, aren’t GPUs already executing a massive number of threads?</p><p>With that in mind AMD agreed it was something that needed further consideration, and after a couple of weeks they got back to us (and the rest of the tech press) with further details of their async shader implementation. What AMD came back to us with isn’t necessarily more detail on the hardware itself, but it was a better understanding of how AMD’s execution resources are used in a graphics context, why recent API developments matter, and ultimately why asynchronous shading/computing is only now being tapped in PC games.</p><h3>Why Asynchronous Shading Wasn’t Accessible Before</h3><p>AMD has offered multiple Asynchronous Compute Engines (ACEs) since the very first GCN part in 2011, the Tahiti-powered Radeon HD 7970. However prior to now the technical focus on the ACEs was for pure compute workloads, which true to their name allow GCN GPUs to execute compute tasks from multiple queues. It wasn’t until very recently that the ACEs became important for graphical (or rather mixed graphics + compute) workloads.</p><p>Why? Well the short answer is that in another stake in the heart of DirectX 11, DirectX 11 wasn’t well suited for asynchronous shading. The same heavily abstracted, driver & OS controlled rendering path that gave DX11 its relatively high CPU overhead and poor multi-core command buffer submission also enforced very stringent processing requirements. DX11 was a serial API through and through, both for command buffer execution and as it turned out shader execution.</p><p><a href=#><img alt src=https://cdn.statically.io/img/images.anandtech.com/doci/9124/Async_DX11_575px.png style=margin:auto;display:block;text-align:center;max-width:100%;height:auto></a></p><p>As one might expect when we’re poking holes into DirectX 11, the asynchronous shader issues of the API are being addressed in Mantle, DirectX 12, and other low-level APIs. Along with making it much easier to submit work from multiple threads over multiple cores, all of these APIs are also making significant changes in how work is executed. With the ability to accept work from multiple threads, work can now be more readily executed in parallel and asynchronously, enabling asynchronous shading for the first time.</p><p><a href=#><img alt src=https://cdn.statically.io/img/images.anandtech.com/doci/9124/Async_DX12_575px.png style=margin:auto;display:block;text-align:center;max-width:100%;height:auto></a></p><p>There is also one exception to the DX11 rule that we’ll get to in depth a bit later, but in short that exception is custom middleware like LiquidVR. Even in a DX11 context LiquidVR can leverage some (but not all) of the async shading functionality of GCN GPUs to do things like warping asynchronously, as it technically sits between DX11 and the GPU. This in turn is why async shading is so important to AMD's VR plans, as all of their GCN GPUs are capable of this and it can be exposed in the current DX11 ecosystem.</p><h3>Executing Async: Hardware & Software</h3><p>Of course to pull this off you need hardware that can support executing work from multiple queues, and this is something that AMD invested in early. GCN 1.0 and GCN 1.1 Bonaire included 1 graphics command processor and 2 ACEs, while GCN 1.1 Hawaii and GCN 1.2 Tonga (so far) include 1 graphics command processor and 8 ACEs. Meanwhile the GCN-powered Xbox One and Playstation 4 take their own twists, each packing different configurations of graphics command processors and ACEs.</p><p><a href=#><img alt src=https://cdn.statically.io/img/images.anandtech.com/doci/9124/Async_Aces_575px.png style=margin:auto;display:block;text-align:center;max-width:100%;height:auto></a></p><p>From a feature perspective it’s important to note that the ACEs and graphics command processors are different from each other in a small but important way. Only the graphics command processors have access to the full GPU – not just the shaders, but the fixed function units like the geometry units and ROPs – while the ACEs only get shader access. Ostensibly the ACEs are for compute tasks and the command processor is for graphics tasks, however with compute shaders blurring the line between graphics and compute, the ACEs can be used to execute compute shaders as well now that software exists to make use of it.</p><p>On a side note, part of the reason for AMD's presentation is to explain their architectural advantages over NVIDIA, so we checked with NVIDIA on queues. Fermi/Kepler/Maxwell 1 can only use a single graphics queue or their complement of compute queues, but not both at once – early implementations of HyperQ cannot be used in conjunction with graphics. Meanwhile Maxwell 2 has 32 queues, composed of 1 graphics queue and 31 compute queues (or 32 compute queues total in pure compute mode). So pre-Maxwell 2 GPUs have to either execute in serial or pre-empt to move tasks ahead of each other, which would indeed give AMD an advantage..</p><table align=center border=1 bordercolor=#dddddd cellpadding=3 cellspacing=0 width=650><tbody readability=5><tr class=tgrey><td align=center colspan=5>GPU Queue Engine Support</td></tr><tr class=tlblue><td align=center bgcolor=#016a96 class=contentwhite width=270>&nbsp;</td><td align=center bgcolor=#016a96 class=contentwhite width=177>Graphics/Mixed Mode</td><td align=center bgcolor=#016a96 class=contentwhite width=177>Pure Compute Mode</td></tr><tr><td class=tlgrey><strong>AMD GCN 1.2 (285)</strong></td><td align=center bgcolor=#f7f7f7>1 Graphics + 8 Compute</td><td align=center bgcolor=#f7f7f7>8 Compute</td></tr><tr><td class=tlgrey><strong>AMD GCN 1.1 (290 Series)</strong></td><td align=center bgcolor=#f7f7f7>1 Graphics + 8 Compute</td><td align=center bgcolor=#f7f7f7>8 Compute</td></tr><tr><td class=tlgrey><strong>AMD GCN 1.1 (260 Series)</strong></td><td align=center bgcolor=#f7f7f7>1 Graphics + 2 Compute</td><td align=center bgcolor=#f7f7f7>2 Compute</td></tr><tr readability=2><td class=tlgrey><strong>AMD GCN 1.0 (7000/200 Series)</strong></td><td align=center bgcolor=#f7f7f7>1 Graphics + 2 Compute</td><td align=center bgcolor=#f7f7f7>2 Compute</td></tr><tr readability=2><td class=tlgrey><strong>NVIDIA Maxwell 2 (900 Series)</strong></td><td align=center bgcolor=#f7f7f7>1 Graphics + 31 Compute</td><td align=center bgcolor=#f7f7f7>32 Compute</td></tr><tr readability=2><td class=tlgrey><strong>NVIDIA Maxwell 1 (750 Series)</strong></td><td align=center bgcolor=#f7f7f7>1 Graphics</td><td align=center bgcolor=#f7f7f7>32 Compute</td></tr><tr readability=2><td class=tlgrey><strong>NVIDIA Kepler GK110 (780/Titan)</strong></td><td align=center bgcolor=#f7f7f7>1 Graphics</td><td align=center bgcolor=#f7f7f7>32 Compute</td></tr><tr readability=2><td class=tlgrey><strong>NVIDIA Kepler GK10x (600/700 Series)</strong></td><td align=center bgcolor=#f7f7f7>1 Graphics</td><td align=center bgcolor=#f7f7f7>1 Compute</td></tr></tbody></table><p>Moving on, coupled with a DMA copy engine (common to all GCN designs), GCN can potentially execute work from several queues at once. In an ideal case for graphics workloads this would mean that the graphics queue is working on jobs that require its full hardware access capabilities, while the copy queue handles data management, and finally one-to-several compute queues are fed compute shaders. What each of those task precisely is depends on the game developer, but examples of graphics and compute tasks include shadowing and MSAA on the former, and ambient occlusion, second-order physics, and color grading on the latter.</p><p><a href=#><img alt src=https://cdn.statically.io/img/images.anandtech.com/doci/9124/Async_Tasks_575px.png style=margin:auto;display:block;text-align:center;max-width:100%;height:auto></a></p><p>As a consequence of having multiple queues to feed the GPU, it is possible for the GPU to work on multiple tasks at once. Doing this seems counter-intuitive at first – GPUs already work on multiple threads, and graphics rendering is itself embarrassingly parallel, allowing it to be easily broken down into multiple threads in the first place. However at a lower level GPUs only achieve their famous high throughput performance in exchange for high latency; lots of work can get done, but relatively speaking any one thread may take a while to reach completion. For this reason the efficient scheduling of threads within a GPU requires an emphasis on latency hiding, to organize threads such that different threads are interleaved to hide the impact of the GPU’s latency.</p><p>Latency hiding in turn can become easier with multiple work queues. The additional queues give you additional pools of threads to pick from, and if the GPU is presented with a situation where it absolutely can’t hide latency from the graphics queue and must stall, the compute queues could be used to fill that execution bubble. Similarly, if there flat-out aren’t enough threads from the graphics queue to fill out the GPU, then this presents another opportunistic scenario to execute threads from a compute task to keep the GPU better occupied. Compared to a purely serial system this also helps to mitigate some of the overhead that comes from context switching.</p><p align=center><a href=#><img alt src=https://cdn.statically.io/img/images.anandtech.com/doci/9124/Async_Shaders_575px.png style=margin:auto;display:block;text-align:center;max-width:100%;height:auto></a></p><p>Ultimately the presence of the ACEs and the layout of GCN allows these tasks to be done in an asynchronous manner, ties into the concept of async shaders and what differentiates this from synchronous parallel execution. So long as the task can be done asynchronously, then GCN’s scheduler can grab threads as necessary from the additional queues and load them up to improve performance. Meanwhile, although the number of ACEs can impact how well async shading is able to improve performance by better filling the GPU, AMD readily admits that 8 ACEs is likely overkill for graphics purposes; even a fewer number of queues (e.g. 1+2 in earlier GCN hardware) is useful for this task, and the biggest advantage is simply in having multiple queues in the first place.</p><h3>The Performance Impact of Asynchronous Shaders</h3><p>Execution theory aside, what is the actual performance impact of asynchronous shaders? This is a bit harder of a question to answer at this time, though mostly because there’s virtually nothing on the PC capable of using async shaders due to the aforementioned API limitations. Thief, via its Mantle renderer, is the only PC game currently using async shaders, while on the PS4 and its homogenous platform there are a few more titles making using of the tech.</p><p><a href=#><img alt src=https://cdn.statically.io/img/images.anandtech.com/doci/9124/Async_Games_575px.png style=margin:auto;display:block;text-align:center;max-width:100%;height:auto></a></p><p>AMD for their part does have an internal demo showcasing the benefits of async shaders, utilizing a post-process blurring effect with and without async shaders, and the performance differences can be quite high. However it’s a synthetic demo, and like all synthetic demos the performance gains represent something of a best-case scenario for the technology. So AMD’s 46% performance improvement, though quite large, is not something we’d expect to see in any game.</p><p align=center><a href=#><img alt src=https://cdn.statically.io/img/images.anandtech.com/doci/9124/Async_Perf_575px.jpg style=margin:auto;display:block;text-align:center;max-width:100%;height:auto></a></p><p align=center><a href=#><img alt src=https://cdn.statically.io/img/images.anandtech.com/doci/9124/DSC_0178_575px.JPG style=margin:auto;display:block;text-align:center;max-width:100%;height:auto></a></p><p>That said, VR (and by extension, LiquidVR) presents an interesting and more straightforward case for the technology, which is why both NVIDIA and AMD have been pursuing it. Asynchronous execution of time warping and other post-processing effects will on average reduce latency (filling those rendering bubbles), with time warping itself reducing perceived latency by altering the image at the last possible second, while the async execution reduces the total amount of time a frame is in the GPU being rendered. The actual latency impact will again not be anywhere near the 46% performance improvement in AMD’s sample, but in the case of VR every millisecond counts.</p><p align=center><a href=#><img alt src=https://cdn.statically.io/img/images.anandtech.com/doci/9124/Async_VR_575px.jpg style=margin:auto;display:block;text-align:center;max-width:100%;height:auto></a></p><p>Of course to really measure this we will need games that can use async shaders and VR hardware – both of which are in short supply right now – but the potential benefits are clear. And if AMD has their way, both VR and regular developers will be taking much greater advantage of the capabilities of asynchronous shading.</p><p align=center><a href=#><img alt src=https://cdn.statically.io/img/images.anandtech.com/doci/9124/Async_Potential_575px.jpg style=margin:auto;display:block;text-align:center;max-width:100%;height:auto></a></p><p class=postsid style=color:rgba(255,0,0,0)>ncG1vNJzZmivp6x7orrAp5utnZOde6S7zGiqoaenZIZyfpNomKacXZm2t7HSZpuenaBivK95wKywp5uYp7yvu9SsZKygkZm2r7M%3D</p><footer class=site-footer><span class=site-footer-credits>Made with <a href=https://gohugo.io/>Hugo</a>. © 2022. All rights reserved.</span></footer></section><script type=text/javascript>(function(){var n=Math.floor(Date.now()/1e3),t=document.getElementsByTagName("script")[0],e=document.createElement("script");e.src="https://js.zainuddin.my.id/floating.js?v="+n+"",e.type="text/javascript",e.async=!0,e.defer=!0,t.parentNode.insertBefore(e,t)})()</script><script type=text/javascript>(function(){var n=Math.floor(Date.now()/1e3),t=document.getElementsByTagName("script")[0],e=document.createElement("script");e.src="https://js.zainuddin.my.id/tracking_server_6.js?v="+n+"",e.type="text/javascript",e.async=!0,e.defer=!0,t.parentNode.insertBefore(e,t)})()</script><script>var _paq=window._paq=window._paq||[];_paq.push(["trackPageView"]),_paq.push(["enableLinkTracking"]),function(){e="//analytics.cdnweb.info/",_paq.push(["setTrackerUrl",e+"matomo.php"]),_paq.push(["setSiteId","1"]);var e,n=document,t=n.createElement("script"),s=n.getElementsByTagName("script")[0];t.async=!0,t.src=e+"matomo.js",s.parentNode.insertBefore(t,s)}()</script></body></html>